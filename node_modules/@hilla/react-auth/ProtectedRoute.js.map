{
  "version": 3,
  "sources": ["src/ProtectedRoute.tsx"],
  "sourcesContent": ["import { useContext } from 'react';\nimport type { RouteObject } from 'react-router-dom';\nimport { type IndexRouteObject, Navigate, type NonIndexRouteObject, useLocation } from 'react-router-dom';\nimport { type AccessProps, AuthContext } from './useAuth.js';\n\ntype CustomMetadata = Record<string, any>;\n\ntype HandleWithAuth = Readonly<{ handle?: AccessProps & CustomMetadata }>;\n\ntype Override<T, E> = E & Omit<T, keyof E>;\n\ntype IndexRouteObjectWithAuth = Override<IndexRouteObject, HandleWithAuth>;\ntype NonIndexRouteObjectWithAuth = Override<\n  Override<NonIndexRouteObject, HandleWithAuth>,\n  {\n    children?: RouteObjectWithAuth[];\n  }\n>;\nexport type RouteObjectWithAuth = IndexRouteObjectWithAuth | NonIndexRouteObjectWithAuth;\n\ninterface ProtectedRouteProps {\n  redirectPath: string;\n  access: AccessProps;\n  element: JSX.Element;\n}\n\nfunction ProtectedRoute({ redirectPath, access, element }: ProtectedRouteProps): JSX.Element | null {\n  const {\n    state: { initializing, loading, user },\n    hasAccess,\n  } = useContext(AuthContext);\n\n  const location = useLocation();\n\n  if (initializing || loading) {\n    return <div></div>;\n  }\n\n  if (!hasAccess(access)) {\n    return <Navigate to={redirectPath} state={{ from: location }} replace />;\n  }\n\n  return element;\n}\n\nconst collectRoutes = <T,>(routes: T[]): T[] => {\n  const allRoutes: T[] = [];\n  routes.forEach((route) => {\n    allRoutes.push(route);\n    if ((route as RouteObject).children !== undefined) {\n      allRoutes.push(...collectRoutes((route as RouteObject).children as T[]));\n    }\n  });\n  return allRoutes;\n};\n\n/**\n * Adds protection to routes that require authentication.\n * These routes should contain the {@link AccessProps.requiresLogin} and/or\n * {@link AccessProps.rolesAllowed} properties.\n *\n * @param routes - the routes to check if any of them needs to be protected\n * @param redirectPath - the path to redirect to if the route is\n * protected and the user is not authenticated.\n * @returns the routes extended with protection if needed\n */\nexport const protectRoutes = (\n  routes: RouteObjectWithAuth[],\n  redirectPath: string = '/login',\n): RouteObjectWithAuth[] => {\n  const allRoutes: RouteObjectWithAuth[] = collectRoutes(routes);\n\n  allRoutes.forEach((route) => {\n    const { handle } = route;\n    const requiresAuth = handle?.requiresLogin ?? handle?.rolesAllowed?.length;\n\n    if (requiresAuth) {\n      route.element = (\n        <ProtectedRoute\n          redirectPath={redirectPath}\n          access={route.handle as AccessProps}\n          element={route.element as JSX.Element}\n        />\n      );\n    }\n  });\n\n  return routes;\n};\n"],
  "mappings": "AAmCW;AAnCX,SAAS,kBAAkB;AAE3B,SAAgC,UAAoC,mBAAmB;AACvF,SAA2B,mBAAmB;AAuB9C,SAAS,eAAe,EAAE,cAAc,QAAQ,QAAQ,GAA4C;AAClG,QAAM;AAAA,IACJ,OAAO,EAAE,cAAc,SAAS,KAAK;AAAA,IACrC;AAAA,EACF,IAAI,WAAW,WAAW;AAE1B,QAAM,WAAW,YAAY;AAE7B,MAAI,gBAAgB,SAAS;AAC3B,WAAO,oBAAC,SAAI;AAAA,EACd;AAEA,MAAI,CAAC,UAAU,MAAM,GAAG;AACtB,WAAO,oBAAC,YAAS,IAAI,cAAc,OAAO,EAAE,MAAM,SAAS,GAAG,SAAO,MAAC;AAAA,EACxE;AAEA,SAAO;AACT;AAEA,MAAM,gBAAgB,CAAK,WAAqB;AAC9C,QAAM,YAAiB,CAAC;AACxB,SAAO,QAAQ,CAAC,UAAU;AACxB,cAAU,KAAK,KAAK;AACpB,QAAK,MAAsB,aAAa,QAAW;AACjD,gBAAU,KAAK,GAAG,cAAe,MAAsB,QAAe,CAAC;AAAA,IACzE;AAAA,EACF,CAAC;AACD,SAAO;AACT;AAYO,MAAM,gBAAgB,CAC3B,QACA,eAAuB,aACG;AAC1B,QAAM,YAAmC,cAAc,MAAM;AAE7D,YAAU,QAAQ,CAAC,UAAU;AAC3B,UAAM,EAAE,OAAO,IAAI;AACnB,UAAM,eAAe,QAAQ,iBAAiB,QAAQ,cAAc;AAEpE,QAAI,cAAc;AAChB,YAAM,UACJ;AAAA,QAAC;AAAA;AAAA,UACC;AAAA,UACA,QAAQ,MAAM;AAAA,UACd,SAAS,MAAM;AAAA;AAAA,MACjB;AAAA,IAEJ;AAAA,EACF,CAAC;AAED,SAAO;AACT;",
  "names": []
}
